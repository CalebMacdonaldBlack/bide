= bide
:sectlinks:

image:http://clojars.org/funcool/bide/latest-version.svg["Clojars Project", link="http://clojars.org/funcool/bide"]


== Introduction

A simple routing library for ClojureScript that uses Express like syntax.

[quote, A Basque proverb.]
____
Egiak ez ditu bi bide
____


== Install

Add the following dependency to your project.clj file:

[source,clojure]
----
[funcool/bide "1.0.0-SNAPSHOT"]
----


== User Guide

Just import the core namespace and start building the router:

[source, clojure]
----
(ns myapp.core
  (:require [bide.core :as r]))

(def router
  (r/build [["/api/auth" :myapp/auth]
            ["/api/users/:id" :myapp/user-by-id]]))
----


Now, you can perform a basic operations such that *match* and *resolve*:

[source, clojure]
----
(r/match router "/api/auth")
;; => [:myapp/auth {}]

(r/match router "/api/users/1")
;; => [:myapp/user-by-id {:id "1"}]

(r/match router "/api/other")
;; => nil

(r/reverse router :myapp/auth)
;; => "/api/auth"

(r/reverse router :myapp/user-by-id {:id 2})
;; => "/api/users/2"
----

And finally, you can integrate it in your ClojureScript web application using
the builtin helpers that uses goog.History api under the hood:

[source, clojure]
----
(defn on-navigate
  "A function which will be called on each route change."
  [name params]
  (println "Route change to: " name params))

(r/start! router {:default :myapp/auth
                  :on-navigate on-navigate})
----

And finally, you can force the navigation trigger using the `navigate!` helper
function:

[source, clojure]
----
(r/navigate! router :myapp/user-by-id {:id 10})
----


== How to Contribute?

Just open an issue or PR ;)


== FAQ

=== Why another routing library?

Just because the existing ones are to complex and with very bloated documentation
that does not explains the essential for the basic use of library.

Many other libraries are focusing on using clojure data structures for represent the
routing in some kind of tree. The concept is very nice but in practice, when you
have complex routing paths, the things becomes dificult to read and understand at
quick view.

Let see a real example using *bidi* routing library:

[source, clojure]
----
(def routes
  ["/" [["auth/login" :auth/login]
        [["auth/recovery/token/" :token] :auth/recovery]
        ["workspace/" [[[:project-uuid "/" :page-uuid] :workspace/page]]]]])
----

The mental effort for read and understand the routing defined in this way is
considerable in comparison to *bide*. Let see an example:

[source, clojure]
----
(def routes
  [["/auth/login" :auth/login]
   ["/auth/recovery/token/:token" :auth/recovery]
   ["/workspace/:project-uuid/:page-uuid" :workspace/page]])
----

Of course, just now *bide* does not offers all the features that the other
libraries, and many of missing stuff will be added over time. But the main purpose
of bide is to stay *small and simple*.


== How fast is *bide*?

Before talking about real performance comparisons and benchmarks, you
should know that *bide* design is very simple and maybe considered
naive. The worst case for the matching algorithm is *O(N)* and *O(1)*
for resolve operation.

But considering the fact that you are not going to have thousands route entries,
the match operation works pretty well. This is a comparison of the equivalent
operations with link:[bidi] library:

[source, text]
----
$ node out/benchmarks.js
op=resolve lib=bidi ops=10000
"Elapsed time: 108.318159 msecs"
op=resolve lib=bide ops=10000
"Elapsed time: 53.742332 msecs"
op=match lib=bidi ops=10000
"Elapsed time: 937.541619 msecs"
op=match lib=bide ops=10000
"Elapsed time: 106.668479 msecs"
----

I compared it to bidi just because before this library I was bidi user.


== License

_bide_ is licensed under BSD (2-Clause) license.
